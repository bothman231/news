For now rename the resulting build from Java_Scheduler_Client to client.war

This is a real simple example of a spring boot executable .war.
You can take the generated .war (as created by maven install) and
drop it on any machine running java
then execute with java -jar Java_Scheduler-0.0.1-SNAPSHOT.war
and it will run and loop based on the schedule set in the code.

You can use this as a heart beat from a remote system.

set env vars
B_CONFIG_ROOT=c:\unique
B_SYSTEM_NAME=hudzen10

Also create a config.properties file at c:\{B_CONFIG_ROOT}\JAVA_CONF\${INSTANCE} with at least a node 
entry in it 
i.e.
node=01
also add checkInUrl property to this file..that corresponds to where the server is running
i.e. checkInUrl=http://fncserver3:5900/api/checkin


java -jar -Dinstance=A js.war

# run passing local env file with name value pairs.

docker run -it --env-file my.env java_scheduler:1



building in docker
docker build -t java_scheduler:1 .


running in docker
docker run java_scheduler:1


1) Run locally inside STS
2) Run inside c:\unique\automation\jobs\startup
3) Run inside docker


Tomcat you can also deploy this to a running TOMCAT instance:-
some work is required on tomcat side, see the docs /Docs/Tomcat/deploy-from-maven

There is an entry to a plugin in the pom that deals with the deployment

you will also have to setup a run config in STS to do the deploy
Right click on project/Run as/Run configurations/Create new 
Basedir:	${workspace_loc:/Java_Scheduler_Client}
Goals:		tomcat7:redeploy







